/*
 *
 *  Created on: 10/29/2020
 *      Author: Group s3-b
 */

#include "adc.h"

/**
 * Initialize ADC0 to use SS0 on PB4
 */
void adc_init(void){//code added on 10/6/20, need to verify accuracy -- if correct, then done?
    //GPIO initialization
    SYSCTL_RCGCGPIO_R |= 0b000010; //enable ADC0 port D clock
    SYSCTL_RCGCADC_R |= 0b0001; //set ADC clock
    GPIO_PORTB_AFSEL_R |= 0x10; //set Port B pin 4 alternate function
    GPIO_PORTB_DIR_R &= 0b11101111; //set port D pin 4 to input
    GPIO_PORTD_DEN_R &= 0b11101111; //set digital enable to off for Port B pin 4
    GPIO_PORTB_AMSEL_R |= 0b00010000; //enable analog mode for pin B4
    GPIO_PORTB_ADCCTL_R = 0x00; //not using any pins to trigger ADC conversion

    //ADC initialization
    ADC0_ACTSS_R &= ~(0x00000002); //during config, disable ADC0 sample sequencer SS1 by clearing bit 0
    ADC0_EMUX_R &= ~(0x000000F0); //set SS1 trigger via ADCPSSI register
    ADC0_SSMUX1_R |= 0x000A; //set first sample to use AIN10 ADC pin
    ADC0_SSCTL1_R = 0x00000000; //clear register to 0 first, going to use channel 1 first, channel 9 second
    ADC0_SSCTL1_R |= 0x00000060; //then set bits 1 and 2 for second sample
    ADC0_SAC_R |= 0x4; //set sample averaging for 16x hardware oversample
    ADC0_ACTSS_R |= 0x00000002;//reenable ADC0 sample sequencer SS1

}

int adc_read(void){

    ADC0_PSSI_R = ADC_PSSI_SS0;//initiate SS1
    while((ADC0_RIS_R & 0x08)== 0){//pause while conversion in process until complete
    }

    int value = ADC0_SSFIFO0_R; //retrieve value stored in SS FIFO containing conversion result
    return value;
}
//void adc_init(void){
//
//    //Turn on the clock for GPIO Port B
//    SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R1;
//    //Turn on the clock for ADC0
//    SYSCTL_RCGCADC_R |= BIT0;
//
//    //Enable alternate function for GPIO PB4
//    GPIO_PORTB_AFSEL_R |= BIT4;
//
//    //Configure the pin PB4 for input and analog mode
//    GPIO_PORTB_DIR_R &= ~BIT4;
//    GPIO_PORTB_DEN_R &= ~BIT4;
//    GPIO_PORTB_AMSEL_R |= BIT4;
//
//    //Don't use PB4 as the trigger source, use the program
//    GPIO_PORTB_ADCCTL_R &= ~BIT4;
//
//    //Disable SS0, sample sequencer 0, for configuration
//    ADC0_ACTSS_R &= ~BIT0;
//
//    //Set SS0 to trigger from ADCPSSI
//    ADC0_EMUX_R &= 0xFFF0;
//
//    //Sample channel 10
//    ADC0_SSMUX0_R |= 0xA;
//
//    //Clear sample sequence control register
//    ADC0_SSCTL0_R = 0x0;
//
//    //Set sample sequencer to end and flag after first sample
//    ADC0_SSCTL0_R |= 0x6;
//
//    //Re-enable ADC0 SS0
//    ADC0_ACTSS_R |= 0x1;
//}
//
//void adc_setAvg(int avg_rate) {
//    if (avg_rate < 8) {
//        ADC0_SAC_R = avg_rate;
//    }
//}
//
//double adc_read(double max_dist){
//
//    //Initiate SS0 conversion sequence
//    ADC0_PSSI_R = 0x1;
//
//    //Wait for SS0 ADC conversions to complete
//    while(~ADC0_RIS_R & BIT0){
//        //waiting
//    }
//
//    //Clear the raw interrupt status flag for SS0
//    ADC0_ISC_R = BIT0;
//
//
//    // Map the timer value to distance
//    double distance = (1.217e8) * pow(ADC0_SSFIFO0_R, - 2.143) + 5;
//
//    // Return 0 if distance is outside usable range of IR sensor
//    return (distance > max_dist ? 0 : distance);
//}


